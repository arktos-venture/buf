// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package indicators_v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// IndicatorsClient is the client API for Indicators service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IndicatorsClient interface {
	// AVGPRICE - Average Price
	AVGPRICE(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error)
	// SMA - Simple Moving Average
	SMA(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error)
	// EMA - Exponential Moving Average
	EMA(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error)
	WMA(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error)
	// VAR - Variance
	VAR(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error)
	// RSI - Relative Strength Index
	RSI(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorRsiReply, error)
	// STDDEV - Standard Deviation
	STDDEV(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error)
	// LINEARREG_SLOPE - Linear Regression Slope
	LINEARREG_SLOPE(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error)
	// DX - Directional Movement Index
	DMI(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error)
	// ADX - Average Directional Movement Index
	ADX(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error)
	// MACD - Moving Average Convergence/Divergence
	MACD(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorMacdReply, error)
	// ATR - Average True Range
	ATR(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error)
	// CCI - Commodity Channel Index
	CCI(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error)
	// BBANDS - Bollinger Bands
	BBANDS(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorBBandsReply, error)
	// WILLR - Williams' %R
	WILLR(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error)
	// SAR - Parabolic SAR
	SAR(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error)
	Health(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type indicatorsClient struct {
	cc grpc.ClientConnInterface
}

func NewIndicatorsClient(cc grpc.ClientConnInterface) IndicatorsClient {
	return &indicatorsClient{cc}
}

func (c *indicatorsClient) AVGPRICE(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error) {
	out := new(IndicatorReply)
	err := c.cc.Invoke(ctx, "/indicators.v1.Indicators/AVGPRICE", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indicatorsClient) SMA(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error) {
	out := new(IndicatorReply)
	err := c.cc.Invoke(ctx, "/indicators.v1.Indicators/SMA", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indicatorsClient) EMA(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error) {
	out := new(IndicatorReply)
	err := c.cc.Invoke(ctx, "/indicators.v1.Indicators/EMA", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indicatorsClient) WMA(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error) {
	out := new(IndicatorReply)
	err := c.cc.Invoke(ctx, "/indicators.v1.Indicators/WMA", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indicatorsClient) VAR(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error) {
	out := new(IndicatorReply)
	err := c.cc.Invoke(ctx, "/indicators.v1.Indicators/VAR", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indicatorsClient) RSI(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorRsiReply, error) {
	out := new(IndicatorRsiReply)
	err := c.cc.Invoke(ctx, "/indicators.v1.Indicators/RSI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indicatorsClient) STDDEV(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error) {
	out := new(IndicatorReply)
	err := c.cc.Invoke(ctx, "/indicators.v1.Indicators/STDDEV", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indicatorsClient) LINEARREG_SLOPE(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error) {
	out := new(IndicatorReply)
	err := c.cc.Invoke(ctx, "/indicators.v1.Indicators/LINEARREG_SLOPE", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indicatorsClient) DMI(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error) {
	out := new(IndicatorReply)
	err := c.cc.Invoke(ctx, "/indicators.v1.Indicators/DMI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indicatorsClient) ADX(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error) {
	out := new(IndicatorReply)
	err := c.cc.Invoke(ctx, "/indicators.v1.Indicators/ADX", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indicatorsClient) MACD(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorMacdReply, error) {
	out := new(IndicatorMacdReply)
	err := c.cc.Invoke(ctx, "/indicators.v1.Indicators/MACD", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indicatorsClient) ATR(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error) {
	out := new(IndicatorReply)
	err := c.cc.Invoke(ctx, "/indicators.v1.Indicators/ATR", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indicatorsClient) CCI(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error) {
	out := new(IndicatorReply)
	err := c.cc.Invoke(ctx, "/indicators.v1.Indicators/CCI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indicatorsClient) BBANDS(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorBBandsReply, error) {
	out := new(IndicatorBBandsReply)
	err := c.cc.Invoke(ctx, "/indicators.v1.Indicators/BBANDS", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indicatorsClient) WILLR(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error) {
	out := new(IndicatorReply)
	err := c.cc.Invoke(ctx, "/indicators.v1.Indicators/WILLR", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indicatorsClient) SAR(ctx context.Context, in *IndicatorRequest, opts ...grpc.CallOption) (*IndicatorReply, error) {
	out := new(IndicatorReply)
	err := c.cc.Invoke(ctx, "/indicators.v1.Indicators/SAR", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indicatorsClient) Health(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/indicators.v1.Indicators/Health", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IndicatorsServer is the server API for Indicators service.
// All implementations must embed UnimplementedIndicatorsServer
// for forward compatibility
type IndicatorsServer interface {
	// AVGPRICE - Average Price
	AVGPRICE(context.Context, *IndicatorRequest) (*IndicatorReply, error)
	// SMA - Simple Moving Average
	SMA(context.Context, *IndicatorRequest) (*IndicatorReply, error)
	// EMA - Exponential Moving Average
	EMA(context.Context, *IndicatorRequest) (*IndicatorReply, error)
	WMA(context.Context, *IndicatorRequest) (*IndicatorReply, error)
	// VAR - Variance
	VAR(context.Context, *IndicatorRequest) (*IndicatorReply, error)
	// RSI - Relative Strength Index
	RSI(context.Context, *IndicatorRequest) (*IndicatorRsiReply, error)
	// STDDEV - Standard Deviation
	STDDEV(context.Context, *IndicatorRequest) (*IndicatorReply, error)
	// LINEARREG_SLOPE - Linear Regression Slope
	LINEARREG_SLOPE(context.Context, *IndicatorRequest) (*IndicatorReply, error)
	// DX - Directional Movement Index
	DMI(context.Context, *IndicatorRequest) (*IndicatorReply, error)
	// ADX - Average Directional Movement Index
	ADX(context.Context, *IndicatorRequest) (*IndicatorReply, error)
	// MACD - Moving Average Convergence/Divergence
	MACD(context.Context, *IndicatorRequest) (*IndicatorMacdReply, error)
	// ATR - Average True Range
	ATR(context.Context, *IndicatorRequest) (*IndicatorReply, error)
	// CCI - Commodity Channel Index
	CCI(context.Context, *IndicatorRequest) (*IndicatorReply, error)
	// BBANDS - Bollinger Bands
	BBANDS(context.Context, *IndicatorRequest) (*IndicatorBBandsReply, error)
	// WILLR - Williams' %R
	WILLR(context.Context, *IndicatorRequest) (*IndicatorReply, error)
	// SAR - Parabolic SAR
	SAR(context.Context, *IndicatorRequest) (*IndicatorReply, error)
	Health(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	mustEmbedUnimplementedIndicatorsServer()
}

// UnimplementedIndicatorsServer must be embedded to have forward compatible implementations.
type UnimplementedIndicatorsServer struct {
}

func (UnimplementedIndicatorsServer) AVGPRICE(context.Context, *IndicatorRequest) (*IndicatorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AVGPRICE not implemented")
}
func (UnimplementedIndicatorsServer) SMA(context.Context, *IndicatorRequest) (*IndicatorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SMA not implemented")
}
func (UnimplementedIndicatorsServer) EMA(context.Context, *IndicatorRequest) (*IndicatorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EMA not implemented")
}
func (UnimplementedIndicatorsServer) WMA(context.Context, *IndicatorRequest) (*IndicatorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WMA not implemented")
}
func (UnimplementedIndicatorsServer) VAR(context.Context, *IndicatorRequest) (*IndicatorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VAR not implemented")
}
func (UnimplementedIndicatorsServer) RSI(context.Context, *IndicatorRequest) (*IndicatorRsiReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RSI not implemented")
}
func (UnimplementedIndicatorsServer) STDDEV(context.Context, *IndicatorRequest) (*IndicatorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method STDDEV not implemented")
}
func (UnimplementedIndicatorsServer) LINEARREG_SLOPE(context.Context, *IndicatorRequest) (*IndicatorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LINEARREG_SLOPE not implemented")
}
func (UnimplementedIndicatorsServer) DMI(context.Context, *IndicatorRequest) (*IndicatorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DMI not implemented")
}
func (UnimplementedIndicatorsServer) ADX(context.Context, *IndicatorRequest) (*IndicatorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ADX not implemented")
}
func (UnimplementedIndicatorsServer) MACD(context.Context, *IndicatorRequest) (*IndicatorMacdReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MACD not implemented")
}
func (UnimplementedIndicatorsServer) ATR(context.Context, *IndicatorRequest) (*IndicatorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ATR not implemented")
}
func (UnimplementedIndicatorsServer) CCI(context.Context, *IndicatorRequest) (*IndicatorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CCI not implemented")
}
func (UnimplementedIndicatorsServer) BBANDS(context.Context, *IndicatorRequest) (*IndicatorBBandsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BBANDS not implemented")
}
func (UnimplementedIndicatorsServer) WILLR(context.Context, *IndicatorRequest) (*IndicatorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WILLR not implemented")
}
func (UnimplementedIndicatorsServer) SAR(context.Context, *IndicatorRequest) (*IndicatorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SAR not implemented")
}
func (UnimplementedIndicatorsServer) Health(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Health not implemented")
}
func (UnimplementedIndicatorsServer) mustEmbedUnimplementedIndicatorsServer() {}

// UnsafeIndicatorsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IndicatorsServer will
// result in compilation errors.
type UnsafeIndicatorsServer interface {
	mustEmbedUnimplementedIndicatorsServer()
}

func RegisterIndicatorsServer(s grpc.ServiceRegistrar, srv IndicatorsServer) {
	s.RegisterService(&Indicators_ServiceDesc, srv)
}

func _Indicators_AVGPRICE_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndicatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndicatorsServer).AVGPRICE(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/indicators.v1.Indicators/AVGPRICE",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndicatorsServer).AVGPRICE(ctx, req.(*IndicatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Indicators_SMA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndicatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndicatorsServer).SMA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/indicators.v1.Indicators/SMA",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndicatorsServer).SMA(ctx, req.(*IndicatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Indicators_EMA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndicatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndicatorsServer).EMA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/indicators.v1.Indicators/EMA",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndicatorsServer).EMA(ctx, req.(*IndicatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Indicators_WMA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndicatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndicatorsServer).WMA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/indicators.v1.Indicators/WMA",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndicatorsServer).WMA(ctx, req.(*IndicatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Indicators_VAR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndicatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndicatorsServer).VAR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/indicators.v1.Indicators/VAR",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndicatorsServer).VAR(ctx, req.(*IndicatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Indicators_RSI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndicatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndicatorsServer).RSI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/indicators.v1.Indicators/RSI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndicatorsServer).RSI(ctx, req.(*IndicatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Indicators_STDDEV_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndicatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndicatorsServer).STDDEV(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/indicators.v1.Indicators/STDDEV",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndicatorsServer).STDDEV(ctx, req.(*IndicatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Indicators_LINEARREG_SLOPE_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndicatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndicatorsServer).LINEARREG_SLOPE(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/indicators.v1.Indicators/LINEARREG_SLOPE",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndicatorsServer).LINEARREG_SLOPE(ctx, req.(*IndicatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Indicators_DMI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndicatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndicatorsServer).DMI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/indicators.v1.Indicators/DMI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndicatorsServer).DMI(ctx, req.(*IndicatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Indicators_ADX_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndicatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndicatorsServer).ADX(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/indicators.v1.Indicators/ADX",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndicatorsServer).ADX(ctx, req.(*IndicatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Indicators_MACD_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndicatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndicatorsServer).MACD(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/indicators.v1.Indicators/MACD",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndicatorsServer).MACD(ctx, req.(*IndicatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Indicators_ATR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndicatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndicatorsServer).ATR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/indicators.v1.Indicators/ATR",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndicatorsServer).ATR(ctx, req.(*IndicatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Indicators_CCI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndicatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndicatorsServer).CCI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/indicators.v1.Indicators/CCI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndicatorsServer).CCI(ctx, req.(*IndicatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Indicators_BBANDS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndicatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndicatorsServer).BBANDS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/indicators.v1.Indicators/BBANDS",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndicatorsServer).BBANDS(ctx, req.(*IndicatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Indicators_WILLR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndicatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndicatorsServer).WILLR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/indicators.v1.Indicators/WILLR",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndicatorsServer).WILLR(ctx, req.(*IndicatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Indicators_SAR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndicatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndicatorsServer).SAR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/indicators.v1.Indicators/SAR",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndicatorsServer).SAR(ctx, req.(*IndicatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Indicators_Health_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndicatorsServer).Health(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/indicators.v1.Indicators/Health",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndicatorsServer).Health(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Indicators_ServiceDesc is the grpc.ServiceDesc for Indicators service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Indicators_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "indicators.v1.Indicators",
	HandlerType: (*IndicatorsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AVGPRICE",
			Handler:    _Indicators_AVGPRICE_Handler,
		},
		{
			MethodName: "SMA",
			Handler:    _Indicators_SMA_Handler,
		},
		{
			MethodName: "EMA",
			Handler:    _Indicators_EMA_Handler,
		},
		{
			MethodName: "WMA",
			Handler:    _Indicators_WMA_Handler,
		},
		{
			MethodName: "VAR",
			Handler:    _Indicators_VAR_Handler,
		},
		{
			MethodName: "RSI",
			Handler:    _Indicators_RSI_Handler,
		},
		{
			MethodName: "STDDEV",
			Handler:    _Indicators_STDDEV_Handler,
		},
		{
			MethodName: "LINEARREG_SLOPE",
			Handler:    _Indicators_LINEARREG_SLOPE_Handler,
		},
		{
			MethodName: "DMI",
			Handler:    _Indicators_DMI_Handler,
		},
		{
			MethodName: "ADX",
			Handler:    _Indicators_ADX_Handler,
		},
		{
			MethodName: "MACD",
			Handler:    _Indicators_MACD_Handler,
		},
		{
			MethodName: "ATR",
			Handler:    _Indicators_ATR_Handler,
		},
		{
			MethodName: "CCI",
			Handler:    _Indicators_CCI_Handler,
		},
		{
			MethodName: "BBANDS",
			Handler:    _Indicators_BBANDS_Handler,
		},
		{
			MethodName: "WILLR",
			Handler:    _Indicators_WILLR_Handler,
		},
		{
			MethodName: "SAR",
			Handler:    _Indicators_SAR_Handler,
		},
		{
			MethodName: "Health",
			Handler:    _Indicators_Health_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/indicators/v1/indicators.proto",
}
