// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: proto/exchanges/v1/exchanges.proto

package v1Exchanges

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ExchangeRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExchangeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExchangeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExchangeRequestMultiError, or nil if none found.
func (m *ExchangeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExchangeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _ExchangeRequest_Ticker_InLookup[m.GetTicker()]; !ok {
		err := ExchangeRequestValidationError{
			field:  "Ticker",
			reason: "value must be in list [NASDAQ NYSE LSE TO V NEO BE HM XETRA DU F HA MU STU LU VI MI PA BR LS VX AS SW MC IR IC NFN RG VS NB HE OL ST TL CO TA HK KO KQ PSE BUD WAR SG BSE SHE SN AT JK JSE BK SR NSE KAR AU SHG CM VN KLSE RO SA BA MX IL ZSE TW LIM CC TWO IS CN INDX GBOND MONEY COMM FOREX]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ExchangeRequestMultiError(errors)
	}

	return nil
}

// ExchangeRequestMultiError is an error wrapping multiple validation errors
// returned by ExchangeRequest.ValidateAll() if the designated constraints
// aren't met.
type ExchangeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExchangeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExchangeRequestMultiError) AllErrors() []error { return m }

// ExchangeRequestValidationError is the validation error returned by
// ExchangeRequest.Validate if the designated constraints aren't met.
type ExchangeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExchangeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExchangeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExchangeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExchangeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExchangeRequestValidationError) ErrorName() string { return "ExchangeRequestValidationError" }

// Error satisfies the builtin error interface
func (e ExchangeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExchangeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExchangeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExchangeRequestValidationError{}

var _ExchangeRequest_Ticker_InLookup = map[string]struct{}{
	"NASDAQ": {},
	"NYSE":   {},
	"LSE":    {},
	"TO":     {},
	"V":      {},
	"NEO":    {},
	"BE":     {},
	"HM":     {},
	"XETRA":  {},
	"DU":     {},
	"F":      {},
	"HA":     {},
	"MU":     {},
	"STU":    {},
	"LU":     {},
	"VI":     {},
	"MI":     {},
	"PA":     {},
	"BR":     {},
	"LS":     {},
	"VX":     {},
	"AS":     {},
	"SW":     {},
	"MC":     {},
	"IR":     {},
	"IC":     {},
	"NFN":    {},
	"RG":     {},
	"VS":     {},
	"NB":     {},
	"HE":     {},
	"OL":     {},
	"ST":     {},
	"TL":     {},
	"CO":     {},
	"TA":     {},
	"HK":     {},
	"KO":     {},
	"KQ":     {},
	"PSE":    {},
	"BUD":    {},
	"WAR":    {},
	"SG":     {},
	"BSE":    {},
	"SHE":    {},
	"SN":     {},
	"AT":     {},
	"JK":     {},
	"JSE":    {},
	"BK":     {},
	"SR":     {},
	"NSE":    {},
	"KAR":    {},
	"AU":     {},
	"SHG":    {},
	"CM":     {},
	"VN":     {},
	"KLSE":   {},
	"RO":     {},
	"SA":     {},
	"BA":     {},
	"MX":     {},
	"IL":     {},
	"ZSE":    {},
	"TW":     {},
	"LIM":    {},
	"CC":     {},
	"TWO":    {},
	"IS":     {},
	"CN":     {},
	"INDX":   {},
	"GBOND":  {},
	"MONEY":  {},
	"COMM":   {},
	"FOREX":  {},
}

// Validate checks the field values on ExchangeSearchRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExchangeSearchRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExchangeSearchRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExchangeSearchRequestMultiError, or nil if none found.
func (m *ExchangeSearchRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExchangeSearchRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCountry()) != 2 {
		err := ExchangeSearchRequestValidationError{
			field:  "Country",
			reason: "value length must be 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetCurrency()) != 3 {
		err := ExchangeSearchRequestValidationError{
			field:  "Currency",
			reason: "value length must be 3 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	// no validation rules for Open

	if len(errors) > 0 {
		return ExchangeSearchRequestMultiError(errors)
	}

	return nil
}

// ExchangeSearchRequestMultiError is an error wrapping multiple validation
// errors returned by ExchangeSearchRequest.ValidateAll() if the designated
// constraints aren't met.
type ExchangeSearchRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExchangeSearchRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExchangeSearchRequestMultiError) AllErrors() []error { return m }

// ExchangeSearchRequestValidationError is the validation error returned by
// ExchangeSearchRequest.Validate if the designated constraints aren't met.
type ExchangeSearchRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExchangeSearchRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExchangeSearchRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExchangeSearchRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExchangeSearchRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExchangeSearchRequestValidationError) ErrorName() string {
	return "ExchangeSearchRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExchangeSearchRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExchangeSearchRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExchangeSearchRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExchangeSearchRequestValidationError{}

// Validate checks the field values on ExchangeDeleteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExchangeDeleteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExchangeDeleteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExchangeDeleteRequestMultiError, or nil if none found.
func (m *ExchangeDeleteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExchangeDeleteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetTickers()) < 1 {
		err := ExchangeDeleteRequestValidationError{
			field:  "Tickers",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_ExchangeDeleteRequest_Tickers_Unique := make(map[string]struct{}, len(m.GetTickers()))

	for idx, item := range m.GetTickers() {
		_, _ = idx, item

		if _, exists := _ExchangeDeleteRequest_Tickers_Unique[item]; exists {
			err := ExchangeDeleteRequestValidationError{
				field:  fmt.Sprintf("Tickers[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_ExchangeDeleteRequest_Tickers_Unique[item] = struct{}{}
		}

		// no validation rules for Tickers[idx]
	}

	if len(errors) > 0 {
		return ExchangeDeleteRequestMultiError(errors)
	}

	return nil
}

// ExchangeDeleteRequestMultiError is an error wrapping multiple validation
// errors returned by ExchangeDeleteRequest.ValidateAll() if the designated
// constraints aren't met.
type ExchangeDeleteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExchangeDeleteRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExchangeDeleteRequestMultiError) AllErrors() []error { return m }

// ExchangeDeleteRequestValidationError is the validation error returned by
// ExchangeDeleteRequest.Validate if the designated constraints aren't met.
type ExchangeDeleteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExchangeDeleteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExchangeDeleteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExchangeDeleteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExchangeDeleteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExchangeDeleteRequestValidationError) ErrorName() string {
	return "ExchangeDeleteRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExchangeDeleteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExchangeDeleteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExchangeDeleteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExchangeDeleteRequestValidationError{}

// Validate checks the field values on ExchangeReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExchangeReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExchangeReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExchangeReplyMultiError, or
// nil if none found.
func (m *ExchangeReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ExchangeReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ticker

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for PrimaryIndice

	for idx, item := range m.GetIndices() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExchangeReplyValidationError{
						field:  fmt.Sprintf("Indices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExchangeReplyValidationError{
						field:  fmt.Sprintf("Indices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExchangeReplyValidationError{
					field:  fmt.Sprintf("Indices[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Routing

	// no validation rules for Country

	// no validation rules for Currency

	// no validation rules for Timezone

	for idx, item := range m.GetHolidays() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExchangeReplyValidationError{
						field:  fmt.Sprintf("Holidays[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExchangeReplyValidationError{
						field:  fmt.Sprintf("Holidays[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExchangeReplyValidationError{
					field:  fmt.Sprintf("Holidays[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TradingHours

	// no validation rules for Open

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExchangeReplyValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExchangeReplyValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExchangeReplyValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExchangeReplyValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExchangeReplyValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExchangeReplyValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExchangeReplyMultiError(errors)
	}

	return nil
}

// ExchangeReplyMultiError is an error wrapping multiple validation errors
// returned by ExchangeReply.ValidateAll() if the designated constraints
// aren't met.
type ExchangeReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExchangeReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExchangeReplyMultiError) AllErrors() []error { return m }

// ExchangeReplyValidationError is the validation error returned by
// ExchangeReply.Validate if the designated constraints aren't met.
type ExchangeReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExchangeReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExchangeReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExchangeReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExchangeReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExchangeReplyValidationError) ErrorName() string { return "ExchangeReplyValidationError" }

// Error satisfies the builtin error interface
func (e ExchangeReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExchangeReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExchangeReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExchangeReplyValidationError{}

// Validate checks the field values on ExchangeReplies with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExchangeReplies) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExchangeReplies with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExchangeRepliesMultiError, or nil if none found.
func (m *ExchangeReplies) ValidateAll() error {
	return m.validate(true)
}

func (m *ExchangeReplies) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExchangeRepliesValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExchangeRepliesValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExchangeRepliesValidationError{
					field:  fmt.Sprintf("Results[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return ExchangeRepliesMultiError(errors)
	}

	return nil
}

// ExchangeRepliesMultiError is an error wrapping multiple validation errors
// returned by ExchangeReplies.ValidateAll() if the designated constraints
// aren't met.
type ExchangeRepliesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExchangeRepliesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExchangeRepliesMultiError) AllErrors() []error { return m }

// ExchangeRepliesValidationError is the validation error returned by
// ExchangeReplies.Validate if the designated constraints aren't met.
type ExchangeRepliesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExchangeRepliesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExchangeRepliesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExchangeRepliesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExchangeRepliesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExchangeRepliesValidationError) ErrorName() string { return "ExchangeRepliesValidationError" }

// Error satisfies the builtin error interface
func (e ExchangeRepliesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExchangeReplies.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExchangeRepliesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExchangeRepliesValidationError{}

// Validate checks the field values on ExchangeDelete with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExchangeDelete) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExchangeDelete with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExchangeDeleteMultiError,
// or nil if none found.
func (m *ExchangeDelete) ValidateAll() error {
	return m.validate(true)
}

func (m *ExchangeDelete) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	if len(errors) > 0 {
		return ExchangeDeleteMultiError(errors)
	}

	return nil
}

// ExchangeDeleteMultiError is an error wrapping multiple validation errors
// returned by ExchangeDelete.ValidateAll() if the designated constraints
// aren't met.
type ExchangeDeleteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExchangeDeleteMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExchangeDeleteMultiError) AllErrors() []error { return m }

// ExchangeDeleteValidationError is the validation error returned by
// ExchangeDelete.Validate if the designated constraints aren't met.
type ExchangeDeleteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExchangeDeleteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExchangeDeleteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExchangeDeleteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExchangeDeleteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExchangeDeleteValidationError) ErrorName() string { return "ExchangeDeleteValidationError" }

// Error satisfies the builtin error interface
func (e ExchangeDeleteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExchangeDelete.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExchangeDeleteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExchangeDeleteValidationError{}

// Validate checks the field values on ExchangeReply_Holiday with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExchangeReply_Holiday) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExchangeReply_Holiday with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExchangeReply_HolidayMultiError, or nil if none found.
func (m *ExchangeReply_Holiday) ValidateAll() error {
	return m.validate(true)
}

func (m *ExchangeReply_Holiday) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Date

	// no validation rules for Official

	if len(errors) > 0 {
		return ExchangeReply_HolidayMultiError(errors)
	}

	return nil
}

// ExchangeReply_HolidayMultiError is an error wrapping multiple validation
// errors returned by ExchangeReply_Holiday.ValidateAll() if the designated
// constraints aren't met.
type ExchangeReply_HolidayMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExchangeReply_HolidayMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExchangeReply_HolidayMultiError) AllErrors() []error { return m }

// ExchangeReply_HolidayValidationError is the validation error returned by
// ExchangeReply_Holiday.Validate if the designated constraints aren't met.
type ExchangeReply_HolidayValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExchangeReply_HolidayValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExchangeReply_HolidayValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExchangeReply_HolidayValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExchangeReply_HolidayValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExchangeReply_HolidayValidationError) ErrorName() string {
	return "ExchangeReply_HolidayValidationError"
}

// Error satisfies the builtin error interface
func (e ExchangeReply_HolidayValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExchangeReply_Holiday.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExchangeReply_HolidayValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExchangeReply_HolidayValidationError{}

// Validate checks the field values on ExchangeReplies_Result with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExchangeReplies_Result) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExchangeReplies_Result with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExchangeReplies_ResultMultiError, or nil if none found.
func (m *ExchangeReplies_Result) ValidateAll() error {
	return m.validate(true)
}

func (m *ExchangeReplies_Result) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ticker

	// no validation rules for Routing

	// no validation rules for Name

	// no validation rules for Open

	if len(errors) > 0 {
		return ExchangeReplies_ResultMultiError(errors)
	}

	return nil
}

// ExchangeReplies_ResultMultiError is an error wrapping multiple validation
// errors returned by ExchangeReplies_Result.ValidateAll() if the designated
// constraints aren't met.
type ExchangeReplies_ResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExchangeReplies_ResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExchangeReplies_ResultMultiError) AllErrors() []error { return m }

// ExchangeReplies_ResultValidationError is the validation error returned by
// ExchangeReplies_Result.Validate if the designated constraints aren't met.
type ExchangeReplies_ResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExchangeReplies_ResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExchangeReplies_ResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExchangeReplies_ResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExchangeReplies_ResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExchangeReplies_ResultValidationError) ErrorName() string {
	return "ExchangeReplies_ResultValidationError"
}

// Error satisfies the builtin error interface
func (e ExchangeReplies_ResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExchangeReplies_Result.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExchangeReplies_ResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExchangeReplies_ResultValidationError{}
