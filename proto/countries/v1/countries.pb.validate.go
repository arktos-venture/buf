// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: proto/countries/v1/countries.proto

package v1Countries

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	v1Screener "github.com/arktos-venture/buf/proto/screener/v1"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = v1Screener.CountryIndicator(0)
)

// Validate checks the field values on CountryRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CountryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CountryRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CountryRequestMultiError,
// or nil if none found.
func (m *CountryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CountryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCountry()) != 2 {
		err := CountryRequestValidationError{
			field:  "Country",
			reason: "value length must be 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return CountryRequestMultiError(errors)
	}

	return nil
}

// CountryRequestMultiError is an error wrapping multiple validation errors
// returned by CountryRequest.ValidateAll() if the designated constraints
// aren't met.
type CountryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CountryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CountryRequestMultiError) AllErrors() []error { return m }

// CountryRequestValidationError is the validation error returned by
// CountryRequest.Validate if the designated constraints aren't met.
type CountryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CountryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CountryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CountryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CountryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CountryRequestValidationError) ErrorName() string { return "CountryRequestValidationError" }

// Error satisfies the builtin error interface
func (e CountryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCountryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CountryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CountryRequestValidationError{}

// Validate checks the field values on CountryCurrencyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CountryCurrencyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CountryCurrencyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CountryCurrencyRequestMultiError, or nil if none found.
func (m *CountryCurrencyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CountryCurrencyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCurrency()) != 3 {
		err := CountryCurrencyRequestValidationError{
			field:  "Currency",
			reason: "value length must be 3 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return CountryCurrencyRequestMultiError(errors)
	}

	return nil
}

// CountryCurrencyRequestMultiError is an error wrapping multiple validation
// errors returned by CountryCurrencyRequest.ValidateAll() if the designated
// constraints aren't met.
type CountryCurrencyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CountryCurrencyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CountryCurrencyRequestMultiError) AllErrors() []error { return m }

// CountryCurrencyRequestValidationError is the validation error returned by
// CountryCurrencyRequest.Validate if the designated constraints aren't met.
type CountryCurrencyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CountryCurrencyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CountryCurrencyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CountryCurrencyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CountryCurrencyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CountryCurrencyRequestValidationError) ErrorName() string {
	return "CountryCurrencyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CountryCurrencyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCountryCurrencyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CountryCurrencyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CountryCurrencyRequestValidationError{}

// Validate checks the field values on CountryIndicatorRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CountryIndicatorRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CountryIndicatorRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CountryIndicatorRequestMultiError, or nil if none found.
func (m *CountryIndicatorRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CountryIndicatorRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Country

	if _, ok := v1Screener.CountryIndicator_name[int32(m.GetIndicator())]; !ok {
		err := CountryIndicatorRequestValidationError{
			field:  "Indicator",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CountryIndicatorRequestMultiError(errors)
	}

	return nil
}

// CountryIndicatorRequestMultiError is an error wrapping multiple validation
// errors returned by CountryIndicatorRequest.ValidateAll() if the designated
// constraints aren't met.
type CountryIndicatorRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CountryIndicatorRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CountryIndicatorRequestMultiError) AllErrors() []error { return m }

// CountryIndicatorRequestValidationError is the validation error returned by
// CountryIndicatorRequest.Validate if the designated constraints aren't met.
type CountryIndicatorRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CountryIndicatorRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CountryIndicatorRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CountryIndicatorRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CountryIndicatorRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CountryIndicatorRequestValidationError) ErrorName() string {
	return "CountryIndicatorRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CountryIndicatorRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCountryIndicatorRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CountryIndicatorRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CountryIndicatorRequestValidationError{}

// Validate checks the field values on CountryReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CountryReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CountryReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CountryReplyMultiError, or
// nil if none found.
func (m *CountryReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CountryReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetGeo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CountryReplyValidationError{
					field:  "Geo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CountryReplyValidationError{
					field:  "Geo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGeo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CountryReplyValidationError{
				field:  "Geo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CountryReplyValidationError{
					field:  "Code",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CountryReplyValidationError{
					field:  "Code",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CountryReplyValidationError{
				field:  "Code",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for EuMember

	// no validation rules for Languages

	for idx, item := range m.GetExchanges() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CountryReplyValidationError{
						field:  fmt.Sprintf("Exchanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CountryReplyValidationError{
						field:  fmt.Sprintf("Exchanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CountryReplyValidationError{
					field:  fmt.Sprintf("Exchanges[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetIndices() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CountryReplyValidationError{
						field:  fmt.Sprintf("Indices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CountryReplyValidationError{
						field:  fmt.Sprintf("Indices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CountryReplyValidationError{
					field:  fmt.Sprintf("Indices[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSubDivision() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CountryReplyValidationError{
						field:  fmt.Sprintf("SubDivision[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CountryReplyValidationError{
						field:  fmt.Sprintf("SubDivision[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CountryReplyValidationError{
					field:  fmt.Sprintf("SubDivision[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CountryReplyMultiError(errors)
	}

	return nil
}

// CountryReplyMultiError is an error wrapping multiple validation errors
// returned by CountryReply.ValidateAll() if the designated constraints aren't met.
type CountryReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CountryReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CountryReplyMultiError) AllErrors() []error { return m }

// CountryReplyValidationError is the validation error returned by
// CountryReply.Validate if the designated constraints aren't met.
type CountryReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CountryReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CountryReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CountryReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CountryReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CountryReplyValidationError) ErrorName() string { return "CountryReplyValidationError" }

// Error satisfies the builtin error interface
func (e CountryReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCountryReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CountryReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CountryReplyValidationError{}

// Validate checks the field values on CountryReplies with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CountryReplies) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CountryReplies with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CountryRepliesMultiError,
// or nil if none found.
func (m *CountryReplies) ValidateAll() error {
	return m.validate(true)
}

func (m *CountryReplies) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CountryRepliesValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CountryRepliesValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CountryRepliesValidationError{
					field:  fmt.Sprintf("Results[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return CountryRepliesMultiError(errors)
	}

	return nil
}

// CountryRepliesMultiError is an error wrapping multiple validation errors
// returned by CountryReplies.ValidateAll() if the designated constraints
// aren't met.
type CountryRepliesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CountryRepliesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CountryRepliesMultiError) AllErrors() []error { return m }

// CountryRepliesValidationError is the validation error returned by
// CountryReplies.Validate if the designated constraints aren't met.
type CountryRepliesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CountryRepliesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CountryRepliesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CountryRepliesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CountryRepliesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CountryRepliesValidationError) ErrorName() string { return "CountryRepliesValidationError" }

// Error satisfies the builtin error interface
func (e CountryRepliesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCountryReplies.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CountryRepliesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CountryRepliesValidationError{}

// Validate checks the field values on CountryIndicatorReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CountryIndicatorReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CountryIndicatorReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CountryIndicatorReplyMultiError, or nil if none found.
func (m *CountryIndicatorReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CountryIndicatorReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Indicator

	// no validation rules for Country

	if all {
		switch v := interface{}(m.GetResults()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CountryIndicatorReplyValidationError{
					field:  "Results",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CountryIndicatorReplyValidationError{
					field:  "Results",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResults()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CountryIndicatorReplyValidationError{
				field:  "Results",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Total

	if len(errors) > 0 {
		return CountryIndicatorReplyMultiError(errors)
	}

	return nil
}

// CountryIndicatorReplyMultiError is an error wrapping multiple validation
// errors returned by CountryIndicatorReply.ValidateAll() if the designated
// constraints aren't met.
type CountryIndicatorReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CountryIndicatorReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CountryIndicatorReplyMultiError) AllErrors() []error { return m }

// CountryIndicatorReplyValidationError is the validation error returned by
// CountryIndicatorReply.Validate if the designated constraints aren't met.
type CountryIndicatorReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CountryIndicatorReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CountryIndicatorReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CountryIndicatorReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CountryIndicatorReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CountryIndicatorReplyValidationError) ErrorName() string {
	return "CountryIndicatorReplyValidationError"
}

// Error satisfies the builtin error interface
func (e CountryIndicatorReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCountryIndicatorReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CountryIndicatorReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CountryIndicatorReplyValidationError{}

// Validate checks the field values on CountryReply_Geo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CountryReply_Geo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CountryReply_Geo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CountryReply_GeoMultiError, or nil if none found.
func (m *CountryReply_Geo) ValidateAll() error {
	return m.validate(true)
}

func (m *CountryReply_Geo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Region

	// no validation rules for SubRegion

	// no validation rules for Continent

	// no validation rules for Capital

	// no validation rules for Area

	if len(errors) > 0 {
		return CountryReply_GeoMultiError(errors)
	}

	return nil
}

// CountryReply_GeoMultiError is an error wrapping multiple validation errors
// returned by CountryReply_Geo.ValidateAll() if the designated constraints
// aren't met.
type CountryReply_GeoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CountryReply_GeoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CountryReply_GeoMultiError) AllErrors() []error { return m }

// CountryReply_GeoValidationError is the validation error returned by
// CountryReply_Geo.Validate if the designated constraints aren't met.
type CountryReply_GeoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CountryReply_GeoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CountryReply_GeoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CountryReply_GeoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CountryReply_GeoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CountryReply_GeoValidationError) ErrorName() string { return "CountryReply_GeoValidationError" }

// Error satisfies the builtin error interface
func (e CountryReply_GeoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCountryReply_Geo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CountryReply_GeoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CountryReply_GeoValidationError{}

// Validate checks the field values on CountryReply_Code with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CountryReply_Code) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CountryReply_Code with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CountryReply_CodeMultiError, or nil if none found.
func (m *CountryReply_Code) ValidateAll() error {
	return m.validate(true)
}

func (m *CountryReply_Code) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Alpha2

	// no validation rules for Alpha3

	// no validation rules for Cioc

	// no validation rules for Ccn3

	// no validation rules for InternationalPrefix

	if len(errors) > 0 {
		return CountryReply_CodeMultiError(errors)
	}

	return nil
}

// CountryReply_CodeMultiError is an error wrapping multiple validation errors
// returned by CountryReply_Code.ValidateAll() if the designated constraints
// aren't met.
type CountryReply_CodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CountryReply_CodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CountryReply_CodeMultiError) AllErrors() []error { return m }

// CountryReply_CodeValidationError is the validation error returned by
// CountryReply_Code.Validate if the designated constraints aren't met.
type CountryReply_CodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CountryReply_CodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CountryReply_CodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CountryReply_CodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CountryReply_CodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CountryReply_CodeValidationError) ErrorName() string {
	return "CountryReply_CodeValidationError"
}

// Error satisfies the builtin error interface
func (e CountryReply_CodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCountryReply_Code.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CountryReply_CodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CountryReply_CodeValidationError{}

// Validate checks the field values on CountryReply_Division with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CountryReply_Division) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CountryReply_Division with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CountryReply_DivisionMultiError, or nil if none found.
func (m *CountryReply_Division) ValidateAll() error {
	return m.validate(true)
}

func (m *CountryReply_Division) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Code

	if all {
		switch v := interface{}(m.GetCoordinates()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CountryReply_DivisionValidationError{
					field:  "Coordinates",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CountryReply_DivisionValidationError{
					field:  "Coordinates",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCoordinates()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CountryReply_DivisionValidationError{
				field:  "Coordinates",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CountryReply_DivisionMultiError(errors)
	}

	return nil
}

// CountryReply_DivisionMultiError is an error wrapping multiple validation
// errors returned by CountryReply_Division.ValidateAll() if the designated
// constraints aren't met.
type CountryReply_DivisionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CountryReply_DivisionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CountryReply_DivisionMultiError) AllErrors() []error { return m }

// CountryReply_DivisionValidationError is the validation error returned by
// CountryReply_Division.Validate if the designated constraints aren't met.
type CountryReply_DivisionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CountryReply_DivisionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CountryReply_DivisionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CountryReply_DivisionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CountryReply_DivisionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CountryReply_DivisionValidationError) ErrorName() string {
	return "CountryReply_DivisionValidationError"
}

// Error satisfies the builtin error interface
func (e CountryReply_DivisionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCountryReply_Division.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CountryReply_DivisionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CountryReply_DivisionValidationError{}

// Validate checks the field values on CountryReply_Division_Coordinate with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CountryReply_Division_Coordinate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CountryReply_Division_Coordinate with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CountryReply_Division_CoordinateMultiError, or nil if none found.
func (m *CountryReply_Division_Coordinate) ValidateAll() error {
	return m.validate(true)
}

func (m *CountryReply_Division_Coordinate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MinLongitude

	// no validation rules for MinLatitude

	// no validation rules for MaxLongitude

	// no validation rules for MaxLatitude

	// no validation rules for Latitude

	// no validation rules for Longitude

	if len(errors) > 0 {
		return CountryReply_Division_CoordinateMultiError(errors)
	}

	return nil
}

// CountryReply_Division_CoordinateMultiError is an error wrapping multiple
// validation errors returned by
// CountryReply_Division_Coordinate.ValidateAll() if the designated
// constraints aren't met.
type CountryReply_Division_CoordinateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CountryReply_Division_CoordinateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CountryReply_Division_CoordinateMultiError) AllErrors() []error { return m }

// CountryReply_Division_CoordinateValidationError is the validation error
// returned by CountryReply_Division_Coordinate.Validate if the designated
// constraints aren't met.
type CountryReply_Division_CoordinateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CountryReply_Division_CoordinateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CountryReply_Division_CoordinateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CountryReply_Division_CoordinateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CountryReply_Division_CoordinateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CountryReply_Division_CoordinateValidationError) ErrorName() string {
	return "CountryReply_Division_CoordinateValidationError"
}

// Error satisfies the builtin error interface
func (e CountryReply_Division_CoordinateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCountryReply_Division_Coordinate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CountryReply_Division_CoordinateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CountryReply_Division_CoordinateValidationError{}

// Validate checks the field values on CountryReplies_Result with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CountryReplies_Result) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CountryReplies_Result with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CountryReplies_ResultMultiError, or nil if none found.
func (m *CountryReplies_Result) ValidateAll() error {
	return m.validate(true)
}

func (m *CountryReplies_Result) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Region

	// no validation rules for Continent

	// no validation rules for Alpha2

	if len(errors) > 0 {
		return CountryReplies_ResultMultiError(errors)
	}

	return nil
}

// CountryReplies_ResultMultiError is an error wrapping multiple validation
// errors returned by CountryReplies_Result.ValidateAll() if the designated
// constraints aren't met.
type CountryReplies_ResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CountryReplies_ResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CountryReplies_ResultMultiError) AllErrors() []error { return m }

// CountryReplies_ResultValidationError is the validation error returned by
// CountryReplies_Result.Validate if the designated constraints aren't met.
type CountryReplies_ResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CountryReplies_ResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CountryReplies_ResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CountryReplies_ResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CountryReplies_ResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CountryReplies_ResultValidationError) ErrorName() string {
	return "CountryReplies_ResultValidationError"
}

// Error satisfies the builtin error interface
func (e CountryReplies_ResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCountryReplies_Result.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CountryReplies_ResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CountryReplies_ResultValidationError{}

// Validate checks the field values on CountryIndicatorReply_Result with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CountryIndicatorReply_Result) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CountryIndicatorReply_Result with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CountryIndicatorReply_ResultMultiError, or nil if none found.
func (m *CountryIndicatorReply_Result) ValidateAll() error {
	return m.validate(true)
}

func (m *CountryIndicatorReply_Result) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCreatedAt() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CountryIndicatorReply_ResultValidationError{
						field:  fmt.Sprintf("CreatedAt[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CountryIndicatorReply_ResultValidationError{
						field:  fmt.Sprintf("CreatedAt[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CountryIndicatorReply_ResultValidationError{
					field:  fmt.Sprintf("CreatedAt[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CountryIndicatorReply_ResultMultiError(errors)
	}

	return nil
}

// CountryIndicatorReply_ResultMultiError is an error wrapping multiple
// validation errors returned by CountryIndicatorReply_Result.ValidateAll() if
// the designated constraints aren't met.
type CountryIndicatorReply_ResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CountryIndicatorReply_ResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CountryIndicatorReply_ResultMultiError) AllErrors() []error { return m }

// CountryIndicatorReply_ResultValidationError is the validation error returned
// by CountryIndicatorReply_Result.Validate if the designated constraints
// aren't met.
type CountryIndicatorReply_ResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CountryIndicatorReply_ResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CountryIndicatorReply_ResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CountryIndicatorReply_ResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CountryIndicatorReply_ResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CountryIndicatorReply_ResultValidationError) ErrorName() string {
	return "CountryIndicatorReply_ResultValidationError"
}

// Error satisfies the builtin error interface
func (e CountryIndicatorReply_ResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCountryIndicatorReply_Result.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CountryIndicatorReply_ResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CountryIndicatorReply_ResultValidationError{}
